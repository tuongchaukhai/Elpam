                + "#include CLR.ahk\n"

+ "class AutoHotInterception {\n"
+ "	_contextManagers := {}\n"

+ "	__New() {\n"
+ "		bitness := A_PtrSize == 8 ? \"x64\" : \"x86\"\n"
+ "		dllName := \"interception.dll\"\n"
+ "		if (A_IsCompiled){\n"
+ "			dllFile := dllName\n"
+ "			FileInstall, AutoHotInterception.dll, AutoHotInterception.dll\n"
+ "			if (bitness == \"x86\"){\n"
+ "				FileInstall, interception.dll, interception.dll\n"
+ "			} else {\n"
+ "				FileInstall, interception.dll, interception.dll\n"
+ "			}\n"
+ "		} else {\n"
+ "			dllFile := dllName\n"
+ "		}\n"
+ "		if (!FileExist(dllFile)) {\n"
+ "			MsgBox % \"Unable to find \" dllFile \", exiting...`nYou should extract both x86 and x64 folders from the library folder in interception.zip into AHI's lib folder.\"\n"
+ "			ExitApp\n"
+ "		}\n"

+ "		hModule := DllCall(\"LoadLibrary\", \"Str\", dllFile, \"Ptr\")\n"
+ "		if (hModule == 0) {\n"
+ "			this_bitness := A_PtrSize == 8 ? \"64-bit\" : \"32-bit\"\n"
+ "			other_bitness := A_PtrSize == 4 ? \"64-bit\" : \"32-bit\"\n"
+ "			MsgBox % \"Bitness of \" dllName \" does not match bitness of AHK.`nAHK is \" this_bitness \", but \" dllName \" is \" other_bitness \".\"\n"
+ "			ExitApp\n"
+ "		}\n"
+ "		DllCall(\"FreeLibrary\", \"Ptr\", hModule)\n"

+ "		dllName := \"AutoHotInterception.dll\"\n"
+ "		if (A_IsCompiled){\n"
+ "			dllFile := dllName\n"
+ "		} else {\n"
+ "			dllFile := dllName\n"
+ "		}\n"
+ "		hintMessage := \"Try right-clicking \" dllFile \", select Properties, and if there is an 'Unblock' checkbox, tick it`nAlternatively, running Unblocker.ps1 in the lib folder (ideally as admin) can do this for you.\"\n"
+ "		if (!FileExist(dllFile)) {\n"
+ "			MsgBox % \"Unable to find \" dllFile \", exiting...\"\n"
+ "			ExitApp\n"
+ "		}\n"

+ "		asm := CLR_LoadLibrary(dllFile)\n"
+ "		try {\n"
+ "			this.Instance := asm.CreateInstance(\"AutoHotInterception.Manager\")\n"
+ "		}\n"
+ "		catch {\n"
+ "			MsgBox % dllName \" failed to load`n`n\" hintMessage\n"
+ "			ExitApp\n"
+ "		}\n"
+ "		if (this.Instance.OkCheck() != \"OK\") {\n"
+ "			MsgBox % dllName \" loaded but check failed!`n`n\" hintMessage\n"
+ "			ExitApp\n"
+ "		}\n"
+ "	}\n"

+ "	GetInstance() {\n"
+ "		return this.Instance\n"
+ "	}\n"

+ "	; --------------- Input Synthesis ----------------\n"
+ "	SendKeyEvent(id, code, state) {\n"
+ "		this.Instance.SendKeyEvent(id, code, state)\n"
+ "	}\n"

+ "	SendMouseButtonEvent(id, btn, state) {\n"
+ "		this.Instance.SendMouseButtonEvent(id, btn, state)\n"
+ "	}\n"

+ "	SendMouseButtonEventAbsolute(id, btn, state, x, y) {\n"
+ "		this.Instance.SendMouseButtonEventAbsolute(id, btn, state, x, y)\n"
+ "	}\n"

+ "	SendMouseMove(id, x, y) {\n"
+ "		this.Instance.SendMouseMove(id, x, y)\n"
+ "	}\n"

+ "	SendMouseMoveRelative(id, x, y) {\n"
+ "		this.Instance.SendMouseMoveRelative(id, x, y)\n"
+ "	}\n"

+ "	SendMouseMoveAbsolute(id, x, y) {\n"
+ "		this.Instance.SendMouseMoveAbsolute(id, x, y)\n"
+ "	}\n"

+ "	SetState(state){\n"
+ "		this.Instance.SetState(state)\n"
+ "	}\n"
+ "	\n"
+ "	MoveCursor(x, y, cm := \"Screen\", mouseId := -1){\n"
+ "		if (mouseId == -1)\n"
+ "			mouseId := 11 ; Use 1st found mouse\n"
+ "		oldMode := A_CoordModeMouse\n"
+ "		CoordMode, Mouse, % cm\n"
+ "		Loop {\n"
+ "			MouseGetPos, cx, cy\n"
+ "			dx := this.GetDirection(cx, x)\n"
+ "			dy := this.GetDirection(cy, y)\n"
+ "			if (dx == 0 && dy == 0)\n"
+ "				break\n"
+ "			this.SendMouseMove(mouseId, dx, dy)\n"
+ "		}\n"
+ "		CoordMode, Mouse, % oldMode\n"
+ "	}\n"
+ "	\n"
+ "	GetDirection(cp, dp){\n"
+ "		d := dp - cp\n"
+ "		if (d > 0)\n"
+ "			return 1\n"
+ "		if (d < 0)\n"
+ "			return -1\n"
+ "		return 0\n"
+ "	}\n"

+ "	; --------------- Querying ------------------------\n"
+ "	GetDeviceId(IsMouse, VID, PID, instance := 1) {\n"
+ "		static devType := {0: \"Keyboard\", 1: \"Mouse\"}\n"
+ "		dev := this.Instance.GetDeviceId(IsMouse, VID, PID, instance)\n"
+ "		if (dev == 0) {\n"
+ "			MsgBox % \"Could not get \" devType[isMouse] \" with VID \" VID \", PID \" PID \", Instance \" instance\n"
+ "			ExitApp\n"
+ "		}\n"
+ "		return dev\n"
+ "	}\n"

+ "	GetDeviceIdFromHandle(isMouse, handle, instance := 1) {\n"
+ "		static devType := {0: \"Keyboard\", 1: \"Mouse\"}\n"
+ "		dev := this.Instance.GetDeviceIdFromHandle(IsMouse, handle, instance)\n"
+ "		if (dev == 0) {\n"
+ "			MsgBox % \"Could not get \" devType[isMouse] \" with Handle \" handle \", Instance \" instance\n"
+ "			ExitApp\n"
+ "		}\n"
+ "		return dev\n"
+ "	}\n"

+ "	GetKeyboardId(VID, PID, instance := 1) {\n"
+ "		return this.GetDeviceId(false, VID, PID, instance)\n"
+ "	}\n"

+ "	GetMouseId(VID, PID, instance := 1) {\n"
+ "		return this.GetDeviceId(true, VID, PID, instance)\n"
+ "	}\n"

+ "	GetKeyboardIdFromHandle(handle, instance := 1) {\n"
+ "		return this.GetDeviceIdFromHandle(false, handle, instance)\n"
+ "	}\n"

+ "	GetMouseIdFromHandle(handle, instance := 1) {\n"
+ "		return this.GetDeviceIdFromHandle(true, handle, instance)\n"
+ "	}\n"

+ "	GetDeviceList() {\n"
+ "		DeviceList := {}\n"
+ "		arr := this.Instance.GetDeviceList()\n"
+ "		for v in arr {\n"
+ "			DeviceList[v.id] := { ID: v.id, VID: v.vid, PID: v.pid, IsMouse: v.IsMouse, Handle: v.Handle }\n"
+ "		}\n"
+ "		return DeviceList\n"
+ "	}\n"

+ "	; ---------------------- Subscription Mode ----------------------\n"
+ "	SubscribeKey(id, code, block, callback, concurrent := false) {\n"
+ "		this.Instance.SubscribeKey(id, code, block, callback, concurrent)\n"
+ "	}\n"

+ "	UnsubscribeKey(id, code){\n"
+ "		this.Instance.UnsubscribeKey(id, code)\n"
+ "	}\n"

+ "	SubscribeKeyboard(id, block, callback, concurrent := false) {\n"
+ "		this.Instance.SubscribeKeyboard(id, block, callback, concurrent)\n"
+ "	}\n"
+ "	\n"
+ "	UnsubscribeKeyboard(id){\n"
+ "		this.Instance.UnsubscribeKeyboard(id)\n"
+ "	}\n"

+ "	SubscribeMouseButton(id, btn, block, callback, concurrent := false) {\n"
+ "		this.Instance.SubscribeMouseButton(id, btn, block, callback, concurrent)\n"
+ "	}\n"

+ "	UnsubscribeMouseButton(id, btn){\n"
+ "		this.Instance.UnsubscribeMouseButton(id, btn)\n"
+ "	}\n"

+ "	SubscribeMouseButtons(id, block, callback, concurrent := false) {\n"
+ "		this.Instance.SubscribeMouseButtons(id, block, callback, concurrent)\n"
+ "	}\n"
+ "	\n"
+ "	UnsubscribeMouseButtons(id){\n"
+ "		this.Instance.UnsubscribeMouseButtons(id)\n"
+ "	}\n"

+ "	SubscribeMouseMove(id, block, callback, concurrent := false) {\n"
+ "		this.Instance.SubscribeMouseMove(id, block, callback, concurrent)\n"
+ "	}\n"

+ "	UnsubscribeMouseMove(id){\n"
+ "		this.Instance.UnsubscribeMouseMove(id)\n"
+ "	}\n"

+ "	SubscribeMouseMoveRelative(id, block, callback, concurrent := false) {\n"
+ "		this.Instance.SubscribeMouseMoveRelative(id, block, callback, concurrent)\n"
+ "	}\n"

+ "	UnsubscribeMouseMoveRelative(id){\n"
+ "		this.Instance.UnsubscribeMouseMoveRelative(id)\n"
+ "	}\n"

+ "	SubscribeMouseMoveAbsolute(id, block, callback, concurrent := false) {\n"
+ "		this.Instance.SubscribeMouseMoveAbsolute(id, block, callback, concurrent)\n"
+ "	}\n"

+ "	UnsubscribeMouseMoveAbsolute(id){\n"
+ "		this.Instance.UnsubscribeMouseMoveAbsolute(id)\n"
+ "	}\n"

+ "	; ------------- Context Mode ----------------\n"
+ "	; Creates a context class to make it easy to turn on/off the hotkeys\n"
+ "	CreateContextManager(id) {\n"
+ "		if (this._contextManagers.HasKey(id)) {\n"
+ "			Msgbox % \"ID \" id \" already has a Context Manager\"\n"
+ "			ExitApp\n"
+ "		}\n"
+ "		cm := new this.ContextManager(this, id)\n"
+ "		this._contextManagers[id] := cm\n"
+ "		return cm\n"
+ "	}\n"

+ "	RemoveContextManager(id) {\n"
+ "		if (!this._contextManagers.HasKey(id)) {\n"
+ "			Msgbox % \"ID \" id \" does not have a Context Manager\"\n"
+ "			ExitApp\n"
+ "		}\n"
+ "		this._contextManagers[id].Remove()\n"
+ "		this._contextManagers.Delete(id)\n"
+ "		return cm\n"
+ "	}\n"

+ "	; Helper class for dealing with context mode\n"
+ "	class ContextManager {\n"
+ "		IsActive := 0\n"
+ "		__New(parent, id) {\n"
+ "			this.parent := parent\n"
+ "			this.id := id\n"
+ "			result := this.parent.Instance.SetContextCallback(id, this.OnContextCallback.Bind(this))\n"
+ "		}\n"
+ "		\n"
+ "		OnContextCallback(state) {\n"
+ "			Sleep 0\n"
+ "			this.IsActive := state\n"
+ "		}\n"
+ "		\n"
+ "		Remove(){\n"
+ "			this.parent.Instance.RemoveContextCallback(this.id)\n"
+ "		}\n"
+ "	}\n"
+ "}\n"