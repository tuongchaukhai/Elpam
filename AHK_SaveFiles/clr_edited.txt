                + "CLR_LoadLibrary(AssemblyName, AppDomain=0) {\n"
+ "	if !AppDomain\n"
+ "		AppDomain := CLR_GetDefaultDomain()\n"
+ "	e := ComObjError(0)\n"
+ "	Loop 1 {\n"
+ "		if assembly := AppDomain.Load_2(AssemblyName)\n"
+ "			break\n"
+ "		static _null := ComObject(13,0)\n"
+ "		args := ComObjArray(0xC, 1),  args[0] := AssemblyName\n"
+ "		typeofAssembly := AppDomain.GetType().Assembly.GetType()\n"
+ "		if assembly := typeofAssembly.InvokeMember_3(\"LoadWithPartialName\", 0x158, _null, _null, args)\n"
+ "			break\n"
+ "		if assembly := typeofAssembly.InvokeMember_3(\"LoadFrom\", 0x158, _null, _null, args)\n"
+ "			break\n"
+ "	}\n"
+ "	ComObjError(e)\n"
+ "	return assembly\n"
+ "}\n"

+ "CLR_CreateObject(Assembly, TypeName, Args*) {\n"
+ "	if !(argCount := Args.MaxIndex())\n"
+ "		return Assembly.CreateInstance_2(TypeName, true)\n"

+ "	vargs := ComObjArray(0xC, argCount)\n"
+ "	Loop % argCount\n"
+ "		vargs[A_Index-1] := Args[A_Index]\n"

+ "	static Array_Empty := ComObjArray(0xC,0), _null := ComObject(13,0)\n"

+ "	return Assembly.CreateInstance_3(TypeName, true, 0, _null, vargs, _null, Array_Empty)\n"
+ "}\n"

+ "CLR_CompileC#(Code, References=\"\", AppDomain=0, FileName=\"\", CompilerOptions=\"\") {\n"
+ "	return CLR_CompileAssembly(Code, References, \"System\", \"Microsoft.CSharp.CSharpCodeProvider\", AppDomain, FileName, CompilerOptions)\n"
+ "}\n"

+ "CLR_CompileVB(Code, References=\"\", AppDomain=0, FileName=\"\", CompilerOptions=\"\") {\n"
+ "	return CLR_CompileAssembly(Code, References, \"System\", \"Microsoft.VisualBasic.VBCodeProvider\", AppDomain, FileName, CompilerOptions)\n"
+ "}\n"

+ "CLR_StartDomain(ByRef AppDomain, BaseDirectory=\"\") {\n"
+ "	static _null := ComObject(13,0)\n"
+ "	args := ComObjArray(0xC, 5), args[0] := \"\", args[2] := BaseDirectory, args[4] := ComObject(0xB,false)\n"
+ "	AppDomain := CLR_GetDefaultDomain().GetType().InvokeMember_3(\"CreateDomain\", 0x158, _null, _null, args)\n"
+ "	return A_LastError >= 0\n"
+ "}\n"

+ "CLR_StopDomain(ByRef AppDomain) {\n"
+ "	; ICorRuntimeHost::UnloadDomain\n"
+ "	DllCall(\"SetLastError\", \"uint\", hr := DllCall(NumGet(NumGet(0+RtHst:=CLR_Start())+20*A_PtrSize), \"ptr\", RtHst, \"ptr\", ComObjValue(AppDomain))), AppDomain := \"\"\n"
+ "	return hr >= 0\n"
+ "}\n"

+ "; NOTE: IT IS NOT NECESSARY TO CALL THIS FUNCTION unless you need to load a specific version.\n"
+ "CLR_Start(Version=\"\") {\n"
+ "	; returns ICorRuntimeHost*\n"
+ "	static RtHst := 0\n"
+ "	; The simple method gives no control over versioning, and seems to load .NET v2 even when v4 is present:\n"
+ "	; return RtHst ? RtHst : (RtHst:=COM_CreateObject(\"CLRMetaData.CorRuntimeHost\",\"{CB2F6722-AB3A-11D2-9C40-00C04FA30A3E}\"), DllCall(NumGet(NumGet(RtHst+0)+40),\"uint\",RtHst))\n"
+ "	if RtHst\n"
+ "		return RtHst\n"
+ "	EnvGet SystemRoot, SystemRoot\n"
+ "	if Version =\n"
+ "		Loop % SystemRoot \"\\Microsoft.NET\\Framework\" (A_PtrSize=8?\"64\":\"\") \"\\*\", 2\n"
+ "			if (FileExist(A_LoopFileFullPath \"\\mscorlib.dll\") && A_LoopFileName > Version)\n"
+ "				Version := A_LoopFileName\n"
+ "	if DllCall(\"mscoree\\CorBindToRuntimeEx\", \"wstr\", Version, \"ptr\", 0, \"uint\", 0\n"
+ "	, \"ptr\", CLR_GUID(CLSID_CorRuntimeHost, \"{CB2F6723-AB3A-11D2-9C40-00C04FA30A3E}\")\n"
+ "	, \"ptr\", CLR_GUID(IID_ICorRuntimeHost,  \"{CB2F6722-AB3A-11D2-9C40-00C04FA30A3E}\")\n"
+ "	, \"ptr*\", RtHst) >= 0\n"
+ "		DllCall(NumGet(NumGet(RtHst+0)+10*A_PtrSize), \"ptr\", RtHst) ; Start\n"
+ "	return RtHst\n"
+ "}\n"

+ ";\n"
+ "; INTERNAL FUNCTIONS\n"
+ ";\n"

+ "CLR_GetDefaultDomain() {\n"
+ "	static defaultDomain := 0\n"
+ "	if !defaultDomain {\n"
+ "		; ICorRuntimeHost::GetDefaultDomain\n"
+ "		if DllCall(NumGet(NumGet(0+RtHst:=CLR_Start())+13*A_PtrSize), \"ptr\", RtHst, \"ptr*\", p:=0) >= 0\n"
+ "			defaultDomain := ComObject(p), ObjRelease(p)\n"
+ "	}\n"
+ "	return defaultDomain\n"
+ "}\n"

+ "CLR_CompileAssembly(Code, References, ProviderAssembly, ProviderType, AppDomain=0, FileName=\"\", CompilerOptions=\"\") {\n"
+ "	if !AppDomain\n"
+ "		AppDomain := CLR_GetDefaultDomain()\n"

+ "	if !(asmProvider := CLR_LoadLibrary(ProviderAssembly, AppDomain))\n"
+ "	|| !(codeProvider := asmProvider.CreateInstance(ProviderType))\n"
+ "	|| !(codeCompiler := codeProvider.CreateCompiler())\n"
+ "		return 0\n"

+ "	if !(asmSystem := (ProviderAssembly=\"System\") ? asmProvider : CLR_LoadLibrary(\"System\", AppDomain))\n"
+ "		return 0\n"

+ "	; Convert | delimited list of references into an array.\n"
+ "	StringSplit, Refs, References, |, %A_Space%%A_Tab%\n"
+ "	aRefs := ComObjArray(8, Refs0)\n"
+ "	Loop % Refs0\n"
+ "		aRefs[A_Index-1] := Refs%A_Index%\n"

+ "	; Set parameters for compiler.\n"
+ "	prms := CLR_CreateObject(asmSystem, \"System.CodeDom.Compiler.CompilerParameters\", aRefs)\n"
+ "	, prms.OutputAssembly          := FileName\n"
+ "	, prms.GenerateInMemory        := FileName=\"\"\n"
+ "	, prms.GenerateExecutable      := SubStr(FileName,-3)=\".exe\"\n"
+ "	, prms.CompilerOptions         := CompilerOptions\n"
+ "	, prms.IncludeDebugInformation := true\n"

+ "	; Compile!\n"
+ "	compilerRes := codeCompiler.CompileAssemblyFromSource(prms, Code)\n"

+ "	if error_count := (errors := compilerRes.Errors).Count {\n"
+ "		error_text := \"\"\n"
+ "		Loop % error_count\n"
+ "			error_text .= ((e := errors.Item[A_Index-1]).IsWarning ? \"Warning \" : \"Error \") . e.ErrorNumber \" on line \" e.Line \": \" e.ErrorText \"`n`n\"\n"
+ "		MsgBox, 16, Compilation Failed, %error_text%\n"
+ "		return 0\n"
+ "	}\n"
+ "	; Success. Return Assembly object or path.\n"
+ "	return compilerRes[FileName=\"\" ? \"CompiledAssembly\" : \"PathToAssembly\"]\n"
+ "}\n"

+ "CLR_GUID(ByRef GUID, sGUID) {\n"
+ "	VarSetCapacity(GUID, 16, 0)\n"
+ "	return DllCall(\"ole32\\CLSIDFromString\", \"wstr\", sGUID, \"ptr\", &GUID) >= 0 ? &GUID : \"\"\n"
+ "}\n